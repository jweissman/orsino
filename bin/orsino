#!/usr/bin/env bun

import Orsino from '../src/orsino';
import { program } from 'commander';
import Generator from '../src/orsino/Generator';
import Books from '../src/orsino/Books';

program
  .name('orsino')
  .description('A versatile content generator for RPGs')
  .version('0.1.0');

program.command('play <type>')
  .description('Play a game based on the type')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  .action(async (type, options) => {
    const orsino = new Orsino(options.setting || 'fantasy');
    await orsino.play(type, options);
    console.log('Thanks for playing!');
    process.exit(0);
  });

program.command('autoplay')
  .description('Autoplay a game')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  .action(async (options) => {
    const orsino = new Orsino(options.setting || 'fantasy');
    await orsino.autoplay(options);
    console.log('Autoplay finished!');
    process.exit(0);
  });

program.command('book <type>')
  .description('Generate a book of the specified type (animals, monsters, spells, traits, skills, items, statuses, wonders, planes, traps, weapons, armor, gear, treasure)')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  .action(async (type, options) => {
    const _orsino = new Orsino(options.setting || 'fantasy');

    let bookshelf = {
      animal: Books.bestiary.bind(Books),
      monster: Books.monsters.bind(Books), spell: Books.spellbook.bind(Books),
      trait: Books.traitbook.bind(Books), skill: Books.skillbook.bind(Books),
      status: Books.statusbook.bind(Books), statuse: Books.statusbook.bind(Books),
      item: Books.itembook.bind(Books), wonder: Books.wonderbook.bind(Books),
      plane: Books.planebook.bind(Books),
      trap: Books.trapbook.bind(Books),
      weapon: Books.weaponbook.bind(Books), armor: Books.armorbook.bind(Books),
      gear: Books.gearbook.bind(Books), treasure: Books.treasurebook.bind(Books),
    }

    let book = bookshelf[type] || bookshelf[type.slice(0, -1)];
    if (book) {
      await book(options);
    } else {
      console.error(`Unknown book type: ${type}`);
    }
    process.exit(0);
  }
);


program
  .command('gen <type>')
  .description('Generate a response based on the type')
  .option('-c, --count <number>', 'Number of items to generate', '1')
  // .option('-g, --graph', 'Assign generated items in a topology with connected edges (implies --count >= 2)')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  // .option('--config <config:value>')
  .option('--name <name>', 'Specify the name to use')
  .option('--race <race>', 'Specify the racial group to use')
  .option('--class <class>', 'Specify the class to use')
  .option('--cr <cr>', 'Specify the challenge rating to target')
  .option('--tabular', 'Print output in tabular format where applicable')
  .action(async (type, options) => {
    // const orsino = new Orsino(options.setting);
    let tabular = options.tabular || false;
    delete options.tabular;

    let cr = options.cr ? parseInt(options.cr) : null;
    delete options.cr;

    if (cr !== null) {
      options._targetCr = cr;
    }
    if (options.name !== null) {
      options._name = options.name;
    }
    if (options.class !== null) {
      options._class = options.class;
    }
    
    // let t0 = Date.now();
    const response = Generator.gen(
      type, // as GenerationTemplateType,
      {
        ...options,
        // _targetCr: cr, // _targetCr: cr,
        // __count: parseInt(options.count) || undefined,
        // __graph: options.graph
      }
    );
    // console.log(response);
    if (tabular) {
      let cleanResponse = { //}: { [key: string]: any } = {
        ...response,
        gear: response.gear ? response.gear.join(", ") : undefined,
        abilities: response.abilities ? response.abilities.join(", ") : undefined,
        traits: response.traits ? response.traits.join(", ") : undefined,
        creatures: response.creatures ? response.creatures.map((c) => c.name).join("; ") : undefined,
        rooms: response.rooms ? response.rooms.map((r) => r.room_type).join("; ") : undefined,
        bossRoom: response.bossRoom ? response.bossRoom.room_type : undefined,

        town: response.town ? response.town.name : undefined,
        dungeons: response.dungeons ? response.dungeons.map((d) => `CR ${d.intendedCr}/${d.race}`).join("; ") : undefined,
      }

      // if any keys undefined, remove them
      Object.keys(cleanResponse).forEach(key => {
        if (cleanResponse[key] === undefined) {
          delete cleanResponse[key];
        }
      });

      console.log();
      console.table(cleanResponse);
    } else {
      process.stdout.write(JSON.stringify(response, null, 2));
    }
    // let t1 = Date.now();
    // console.error(`\nGenerated in ${(t1 - t0)} ms.`);
    // Files.write(`data/${type}s/${response['name']}.json`, JSON.stringify(response, null, 2));
  });

program.parse(process.argv);
