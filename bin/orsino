#!/usr/bin/env bun

import Orsino from '../src/orsino';
import { GenerationTemplateType } from "../src/orsino/types/GenerationTemplateType";
import { program } from 'commander';
import Generator from '../src/orsino/Generator';

program
  .name('orsino')
  .description('A versatile content generator for RPGs')
  .version('0.1.0');

program.command('play <type>')
  .description('Play a game based on the type')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  .action(async (type, options) => {
    const orsino = new Orsino(options.setting || 'fantasy');
    await orsino.play(type as any, options);
    console.log('Thanks for playing!');
    process.exit(0);
  });

program.command('autoplay')
  .description('Autoplay a game')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  .action(async (options) => {
    const orsino = new Orsino(options.setting || 'fantasy');
    await orsino.autoplay(options);
    console.log('Autoplay finished!');
    process.exit(0);
  });

program.command('mm')
  .description('Generate a monster manual for all monsters in the setting')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  .action(async (options) => {
    const orsino = new Orsino(options.setting || 'fantasy');
    await orsino.monsterManual(options);
    process.exit(0);
  });

program
  .command('gen <type>')
  .description('Generate a response based on the type')
  .option('-c, --count <number>', 'Number of items to generate', '1')
  // .option('-g, --graph', 'Assign generated items in a topology with connected edges (implies --count >= 2)')
  .option('-s, --setting <setting>', 'Specify the setting to use', 'fantasy')
  // .option('--config <config:value>')
  .option('--race <race>', 'Specify the racial group to use')
  .option('--class <class>', 'Specify the class to use')
  .option('--cr <cr>', 'Specify the challenge rating to target')
  .option('--tabular', 'Print output in tabular format where applicable')
  .action(async (type, options) => {
    // const orsino = new Orsino(options.setting);
    // if (options.graph && parseInt(options.count) < 2) {
    //   console.error('Graph generation requires at least 2 items. Use --count to specify the number of items.');
    //   process.exit(1);
    // }
    let tabular = options.tabular || false;
    delete options.tabular;

    let cr = options.cr ? parseInt(options.cr) : null;
    delete options.cr;

    if (cr !== null) {
      options._targetCr = cr;
    }
    
    const response = await Generator.gen(
      type as GenerationTemplateType,
      {
        ...options,
        // _targetCr: cr, // _targetCr: cr,
        // __count: parseInt(options.count) || undefined,
        // __graph: options.graph
      }
    );
    // console.log(response);
    if (tabular) {
      let cleanResponse: { [key: string]: any } = {
        ...response,
        gear: response.gear ? response.gear.join(", ") : undefined,
        abilities: response.abilities ? response.abilities.join(", ") : undefined,
        traits: response.traits ? response.traits.join(", ") : undefined,
        creatures: response.creatures ? response.creatures.map((c: any) => c.name).join("; ") : undefined,
        rooms: response.rooms ? response.rooms.map((r: any) => r.room_type).join("; ") : undefined,
        bossRoom: response.bossRoom ? response.bossRoom.room_type : undefined,

        town: response.town ? response.town.name : undefined,
        dungeons: response.dungeons ? response.dungeons.map((d: any) => `CR ${d.intendedCr}/${d.race}`).join("; ") : undefined,
      }

      // if any keys undefined, remove them
      Object.keys(cleanResponse).forEach(key => {
        if (cleanResponse[key] === undefined) {
          delete cleanResponse[key];
        }
      });

      console.log();
      console.table(cleanResponse);
    } else {
      process.stdout.write(JSON.stringify(response, null, 2));
    }
    // Files.write(`data/${type}s/${response['name']}.json`, JSON.stringify(response, null, 2));
  });

program.parse(process.argv);
